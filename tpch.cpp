/* This file is part of Toilet. Toilet is copyright 2007-2009 The Regents
 * of the University of California. It is distributed under the terms of
 * version 2 of the GNU GPL. See the file LICENSE for details. */

#define _ATFILE_SOURCE

#include <time.h>
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <sys/time.h>

#include "openat.h"
#include "transaction.h"

#include "dtable_factory.h"
#include "ctable_factory.h"

extern "C" {
int command_tpchtype(int argc, const char * argv[]);
int command_tpchgen(int argc, const char * argv[]);
int command_tpchtest(int argc, const char * argv[]);
};

/* this class reads |-delimited data lines, as generated by dbgen */
template<size_t max_columns, size_t line_length = 380>
class tbl_reader {
public:
	tbl_reader(const char * file)
	{
		line_number = 0;
		input = fopen(file, "r");
		if(input)
			next();
	}
	bool valid() const
	{
		return !!input;
	}
	size_t number() const
	{
		return line_number;
	}
	bool next()
	{
		int i = 0;
		if(!input)
			return false;
		if(!fgets(line, sizeof(line), input))
		{
			fclose(input);
			input = NULL;
			return false;
		}
		line_number++;
		for(size_t c = 0; c < max_columns; c++)
		{
			column[c] = &line[i];
			for(; line[i] && line[i] != '|'; i++);
			if(line[i])
				line[i++] = 0;
		}
		return true;
	}
	const char * get(size_t index) const
	{
		assert(index < max_columns);
		return column[index];
	}
	~tbl_reader()
	{
		if(input)
			fclose(input);
	}
private:
	FILE * input;
	size_t line_number;
	char line[line_length];
	const char * column[max_columns];
};

/* FIXME: we should have a key array dtable, for indexing based on integer keys but variable size values */
/* FIXME: an ascii dtable would be nice too, ignoring the high bit of each byte (difficulty: how to calculate decoded size?) */
#include "tpch_config.h"

struct tpch_table_info {
	const char * name;
	istr type;
	const char * config;
};
enum tpch_table {
	PART = 0,
	CUSTOMER = 1,
	ORDERS = 2,
	LINEITEM = 3
};
static const tpch_table_info tpch_column_tables[4] = {
	{"part", "column_ctable", tpch_part_column_config},
	{"customer", "column_ctable", tpch_customer_column_config},
	{"orders", "column_ctable", tpch_orders_column_config},
	{"lineitem", "column_ctable", tpch_lineitem_column_config}
};
static const tpch_table_info tpch_row_tables[4] = {
	{"part", "simple_ctable", tpch_part_row_config},
	{"customer", "simple_ctable", tpch_customer_row_config},
	{"orders", "simple_ctable", tpch_orders_row_config},
	{"lineitem", "simple_ctable", tpch_lineitem_row_config}
};
static const tpch_table_info * tpch_tables = tpch_column_tables;

int command_tpchtype(int argc, const char * argv[])
{
	const char * now = "";
	const char * type = (tpch_tables == tpch_column_tables) ? "column" : "row";
	if(argc > 1)
	{
		now = "now ";
		type = argv[1];
		if(!strcmp(argv[1], "row"))
			tpch_tables = tpch_row_tables;
		else if(!strcmp(argv[1], "column"))
			tpch_tables = tpch_column_tables;
		else
		{
			printf("Unknown table type: %s\n", argv[1]);
			type = NULL;
		}
	}
	if(type)
		printf("TPC-H tests will %suse %s-based tables.\n", now, type);
	return 0;
}

static ctable * create_and_open(const tpch_table_info & info)
{
	int r;
	params config;
	ctable * table;
	
	r = params::parse(info.config, &config);
	printf("params::parse = %d\n", r);
	config.print();
	printf("\n");
	
	r = tx_start();
	printf("tx_start = %d\n", r);
	r = ctable_factory::setup(info.type, AT_FDCWD, info.name, config, dtype::UINT32);
	printf("ctable::create = %d\n", r);
	r = tx_end(0);
	printf("tx_end = %d\n", r);
	
	table = ctable_factory::load(info.type, AT_FDCWD, info.name, config);
	printf("ctable_factory::load = %p\n", table);
	
	return table;
}

static void maintain_restart_tx(ctable * table)
{
	printf("maintain... ");
	fflush(stdout);
	int r = table->maintain(true);
	printf("\rmaintain = %d\n", r);
	r = tx_end(0);
	if(r < 0)
		printf("tx_end = %d\n", r);
	else
	{
		r = tx_start();
		if(r < 0)
			printf("tx_start = %d\n", r);
	}
}

static void create_part()
{
	ctable * table = create_and_open(tpch_tables[PART]);
	int r = tx_start();
	printf("tx_start = %d\n", r);
	
	tbl_reader<9> part_tbl("tpch/part.tbl");
	while(part_tbl.valid())
	{
		uint32_t key = atoi(part_tbl.get(0));
		uint32_t p_size;
		float p_retailprice;
		const char * char_values[8];
		ctable::colval values[8];
		for(size_t i = 0; i < 8; i++)
		{
			values[i].index = i;
			char_values[i] = part_tbl.get(i + 1);
		}
		values[0].value = blob(char_values[0]); /* p_name */
		values[1].value = blob(char_values[1]); /* p_mfgr */
		values[2].value = blob(char_values[2]); /* p_brand */
		values[3].value = blob(char_values[3]); /* p_type */
		p_size = strtol(char_values[4], NULL, 0);
		values[4].value = blob(sizeof(p_size), &p_size);
		values[5].value = blob(char_values[5]); /* p_container */
		p_retailprice = strtod(char_values[6], NULL);
		values[6].value = blob(sizeof(p_retailprice), &p_retailprice);
		values[7].value = blob(char_values[7]); /* p_comment */
		r = table->insert(key, values, 8, true);
		if(r < 0)
			printf("insert = %d\n", r);
		if(!(part_tbl.number() % 500000))
			maintain_restart_tx(table);
		part_tbl.next();
	}
	
	printf("digest_on_close\n");
	delete table;
	r = tx_end(0);
	printf("tx_end = %d\n", r);
}

static void create_customer()
{
	ctable * table = create_and_open(tpch_tables[CUSTOMER]);
	int r = tx_start();
	printf("tx_start = %d\n", r);
	
	tbl_reader<8> customer_tbl("tpch/customer.tbl");
	while(customer_tbl.valid())
	{
		uint32_t key = atoi(customer_tbl.get(0));
		uint32_t c_nationkey;
		float c_acctbal;
		const char * char_values[7];
		ctable::colval values[7];
		for(size_t i = 0; i < 7; i++)
		{
			values[i].index = i;
			char_values[i] = customer_tbl.get(i + 1);
		}
		values[0].value = blob(char_values[0]); /* c_name */
		values[1].value = blob(char_values[1]); /* c_address */
		c_nationkey = strtol(char_values[2], NULL, 0);
		values[2].value = blob(sizeof(c_nationkey), &c_nationkey);
		values[3].value = blob(char_values[3]); /* c_phone */
		c_acctbal = strtod(char_values[4], NULL);
		values[4].value = blob(sizeof(c_acctbal), &c_acctbal);
		values[5].value = blob(char_values[5]); /* c_mktsegment */
		values[6].value = blob(char_values[6]); /* c_comment */
		r = table->insert(key, values, 7, true);
		if(r < 0)
			printf("insert = %d\n", r);
		if(!(customer_tbl.number() % 500000))
			maintain_restart_tx(table);
		customer_tbl.next();
	}
	
	printf("digest_on_close\n");
	delete table;
	r = tx_end(0);
	printf("tx_end = %d\n", r);
}

static void create_orders()
{
	ctable * table = create_and_open(tpch_tables[ORDERS]);
	int r = tx_start();
	printf("tx_start = %d\n", r);
	
	tbl_reader<9> orders_tbl("tpch/orders.tbl");
	while(orders_tbl.valid())
	{
		uint32_t key = atoi(orders_tbl.get(0));
		uint32_t o_custkey, o_shippriority;
		float o_totalprice;
		const char * char_values[8];
		ctable::colval values[8];
		for(size_t i = 0; i < 8; i++)
		{
			values[i].index = i;
			char_values[i] = orders_tbl.get(i + 1);
		}
		o_custkey = strtol(char_values[0], NULL, 0);
		values[0].value = blob(sizeof(o_custkey), &o_custkey);
		values[1].value = blob(char_values[1]); /* o_orderstatus */
		o_totalprice = strtod(char_values[2], NULL);
		values[2].value = blob(sizeof(o_totalprice), &o_totalprice);
		values[3].value = blob(char_values[3]); /* o_orderdate */
		values[4].value = blob(char_values[4]); /* o_orderpriority */
		values[5].value = blob(char_values[5]); /* o_clerk */
		o_shippriority = strtol(char_values[6], NULL, 0);
		values[6].value = blob(sizeof(o_shippriority), &o_shippriority);
		values[7].value = blob(char_values[7]); /* o_comment */
		r = table->insert(key, values, 8, true);
		if(r < 0)
			printf("insert = %d\n", r);
		if(!(orders_tbl.number() % 500000))
			maintain_restart_tx(table);
		orders_tbl.next();
	}
	
	printf("digest_on_close\n");
	delete table;
	r = tx_end(0);
	printf("tx_end = %d\n", r);
}

static void create_lineitem()
{
	ctable * table = create_and_open(tpch_tables[LINEITEM]);
	int r = tx_start();
	printf("tx_start = %d\n", r);
	
	tbl_reader<16> lineitem_tbl("tpch/lineitem.tbl");
	while(lineitem_tbl.valid())
	{
		uint32_t key = lineitem_tbl.number();
		uint32_t l_orderkey, l_partkey, l_suppkey, l_linenumber;
		float l_quantity, l_extendedprice, l_discount, l_tax;
		const char * char_values[16];
		ctable::colval values[16];
		for(size_t i = 0; i < 16; i++)
		{
			values[i].index = i;
			char_values[i] = lineitem_tbl.get(i);
		}
		l_orderkey = strtol(char_values[0], NULL, 0);
		values[0].value = blob(sizeof(l_orderkey), &l_orderkey);
		l_partkey = strtol(char_values[1], NULL, 0);
		values[1].value = blob(sizeof(l_partkey), &l_partkey);
		l_suppkey = strtol(char_values[2], NULL, 0);
		values[2].value = blob(sizeof(l_suppkey), &l_suppkey);
		l_linenumber = strtol(char_values[3], NULL, 0);
		values[3].value = blob(sizeof(l_linenumber), &l_linenumber);
		l_quantity = strtod(char_values[4], NULL);
		values[4].value = blob(sizeof(l_quantity), &l_quantity);
		l_extendedprice = strtod(char_values[5], NULL);
		values[5].value = blob(sizeof(l_extendedprice), &l_extendedprice);
		l_discount = strtod(char_values[6], NULL);
		values[6].value = blob(sizeof(l_discount), &l_discount);
		l_tax = strtod(char_values[7], NULL);
		values[7].value = blob(sizeof(l_tax), &l_tax);
		values[8].value = blob(char_values[8]); /* l_returnflag */
		values[9].value = blob(char_values[9]); /* l_linestatus */
		values[10].value = blob(char_values[10]); /* l_shipdate */
		values[11].value = blob(char_values[11]); /* l_commitdate */
		values[12].value = blob(char_values[12]); /* l_receiptdate */
		values[13].value = blob(char_values[13]); /* l_shipinstruct */
		values[14].value = blob(char_values[14]); /* l_shipmode */
		values[15].value = blob(char_values[15]); /* l_comment */
		r = table->insert(key, values, 16, true);
		if(r < 0)
			printf("insert = %d\n", r);
		if(!(lineitem_tbl.number() % 500000))
			maintain_restart_tx(table);
		lineitem_tbl.next();
	}
	
	printf("digest_on_close\n");
	delete table;
	r = tx_end(0);
	printf("tx_end = %d\n", r);
}

/* import the part, customer, orders, and lineitem tables */
int command_tpchgen(int argc, const char * argv[])
{
	create_part();
	create_customer();
	create_orders();
	create_lineitem();
	return 0;
}

static ctable * open_in_tx(const tpch_table_info & info)
{
	int r;
	params config;
	ctable * table;
	
	r = params::parse(info.config, &config);
	printf("params::parse = %d\n", r);
	config.print();
	printf("\n");
	
	r = tx_start();
	printf("tx_start = %d\n", r);
	table = ctable_factory::load(info.type, AT_FDCWD, info.name, config);
	printf("ctable_factory::load = %p\n", table);
	r = tx_end(0);
	printf("tx_end = %d\n", r);
	
	return table;
}

int command_tpchtest(int argc, const char * argv[])
{
	ctable * part = open_in_tx(tpch_tables[PART]);
	ctable * customer = open_in_tx(tpch_tables[CUSTOMER]);
	ctable * orders = open_in_tx(tpch_tables[ORDERS]);
	ctable * lineitem = open_in_tx(tpch_tables[LINEITEM]);
	/* #6 select sum(l_extendedprice * l_discount) as revenue
	 * from lineitem
	 * where l_shipdate >= date '[DATE]' and
	 * l_shipdate < date '[DATE]' + interval '1' year and
	 * l_discount between [DISCOUNT] - 0.01 and [DISCOUNT] + 0.01 and
	 * l_quantity < [QUANTITY];
	 * [DATE] is Jan 1 [1993-1997]
	 * [DISCOUNT] in [.02-.09]
	 * [QUANTITY] is 24 or 25 */
	if(tpch_tables == tpch_column_tables)
	{
		/* this way is more effective for a column store */
		dtable::iter * l_extendedprice = lineitem->values("l_extendedprice");
		dtable::iter * l_discount = lineitem->values("l_discount");
		float revenue = 0;
		while(l_extendedprice->valid() && l_discount->valid())
		{
			/* the keys should be the same */
			assert(!l_extendedprice->key().compare(l_discount->key()));
			float extendedprice = l_extendedprice->value().index<float>(0);
			float discount = l_discount->value().index<float>(0);
			revenue += extendedprice * discount;
			l_extendedprice->next();
			l_discount->next();
		}
		printf("revenue = %g\n", revenue);
	}
	else
	{
		/* this way is more effective for a row store */
		size_t l_extendedprice = lineitem->index("l_extendedprice");
		size_t l_discount = lineitem->index("l_discount");
		ctable::iter * iter = lineitem->iterator();
		float revenue = 0;
		while(iter->valid())
		{
			float extendedprice = iter->index(l_extendedprice).index<float>(0);
			float discount = iter->index(l_discount).index<float>(0);
			revenue += extendedprice * discount;
			/* next row, not next column */
			iter->next(true);
		}
		printf("revenue = %g\n", revenue);
	}
	/* #14 select 100 * sum(case when p_type like 'PROMO%' then l_extendedprice * (1 - l_discount) else 0 end)
	 * / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
	 * from lineitem, part
	 * where l_partkey = p_partkey and
	 * l_shipdate >= date '[DATE]' and
	 * l_shipdate < date '[DATE]' + interval '1' month;
	 * [DATE] is [Jan-Dec] 1 [1993-1997]
	 * Types: [STANDARD SMALL MEDIUM LARGE ECONOMY PROMO][ANODIZED BURNISHED PLATED POLISHED BRUSHED][TIN NICKEL BRASS STEEL COPPER] */
	/* #17 select sum(l_extendedprice) / 7.0 as avg_yearly
	 * from lineitem, part
	 * where p_partkey = l_partkey and
	 * p_brand = '[BRAND]' and
	 * p_container = '[CONTAINER]' and
	 * l_quantity < (select 0.2 * avg(l_quantity) from lineitem where l_partkey = p_partkey);
	 * [BRAND] is 'Brand#MN' with M, N in [1-5]
	 * [CONTAINER] [Containers]
	 * Containers: [SM LG MED JUMBO WRAP][CASE BOX BAG JAR PKG PACK CAN DRUM] (page 90) */
	delete lineitem;
	delete orders;
	delete customer;
	delete part;
	return 0;
}
