/* This file is part of Toilet. Toilet is copyright 2007-2009 The Regents
 * of the University of California. It is distributed under the terms of
 * version 2 of the GNU GPL. See the file LICENSE for details. */

#define _ATFILE_SOURCE

#include <time.h>
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <sys/time.h>

#include "openat.h"
#include "transaction.h"

#include "dtable_factory.h"
#include "ctable_factory.h"

extern "C" {
int command_tpchgen(int argc, const char * argv[]);
int command_tpchtest(int argc, const char * argv[]);
};

/* this class reads |-delimited data lines, as generated by dbgen */
template<size_t max_columns, size_t line_length = 380>
class tbl_reader {
public:
	tbl_reader(const char * file)
	{
		line_number = 0;
		input = fopen(file, "r");
		if(input)
			next();
	}
	bool valid() const
	{
		return !!input;
	}
	size_t number() const
	{
		return line_number;
	}
	bool next()
	{
		int i = 0;
		if(!input)
			return false;
		if(!fgets(line, sizeof(line), input))
		{
			fclose(input);
			input = NULL;
			return false;
		}
		line_number++;
		for(size_t c = 0; c < max_columns; c++)
		{
			column[c] = &line[i];
			for(; line[i] && line[i] != '|'; i++);
			if(line[i])
				line[i++] = 0;
		}
		return true;
	}
	const char * get(size_t index) const
	{
		assert(index < max_columns);
		return column[index];
	}
	~tbl_reader()
	{
		if(input)
			fclose(input);
	}
private:
	FILE * input;
	size_t line_number;
	char line[line_length];
	const char * column[max_columns];
};

/* FIXME: we should have a key array dtable, for indexing based on integer keys but variable size values */
/* FIXME: an ascii dtable would be nice too, ignoring the high bit of each byte (difficulty: how to calculate decoded size?) */

/* part:
 *  p_partkey,
 *  p_name (55v),
 *  p_mfgr (25f),
 *  p_brand (10f),
 *  p_type (25v),
 *  p_size (int),
 *  p_container (10f),
 *  p_retailprice (float),
 *  p_comment (23v) */
static const char * tpch_part_config = LITERAL(
	config [
		"columns" int 8
		"base" class(dt) managed_dtable
		"base_config" config [
			"base" class(dt) simple_dtable
			"digest_on_close" bool true
		]
		"column0_name" string "p_name"
		"column1_name" string "p_mfgr"
		"column2_name" string "p_brand"
		"column3_name" string "p_type"
		"column4_name" string "p_size"
		"column5_name" string "p_container"
		"column6_name" string "p_retailprice"
		"column7_name" string "p_comment"
		"column1_config" config [
			"base" class(dt) exception_dtable
			"base_config" config [
				"base" class(dt) array_dtable
				"alt" class(dt) simple_dtable
				"reject_value" string "______________"
			]
			"digest_on_close" bool true
		]
		"column2_config" config [
			"base" class(dt) exception_dtable
			"base_config" config [
				"base" class(dt) array_dtable
				"alt" class(dt) simple_dtable
				"reject_value" string "________"
			]
			"digest_on_close" bool true
		]
		"column4_config" config [
			"base" class(dt) exception_dtable
			"base_config" config [
				"base" class(dt) smallint_dtable
				"base_config" config [
					"base" class(dt) array_dtable
					"bytes" int 1
				]
				"alt" class(dt) simple_dtable
				"reject_value" blob 00000000
			]
			"digest_on_close" bool true
		]
		"column6_config" config [
			"base" class(dt) array_dtable
			"base_config" config [
				"value_size" int 4
			]
			"digest_on_close" bool true
		]
	]);

/* customer:
 *  c_custkey,
 *  c_name (25v),
 *  c_address (40v),
 *  c_nationkey (id),
 *  c_phone (15f),
 *  c_acctbal (float),
 *  c_mktsegment (10f),
 *  c_comment (117v) */
static const char * tpch_customer_config = LITERAL(
	config [
		"columns" int 7
		"base" class(dt) managed_dtable
		"base_config" config [
			"base" class(dt) simple_dtable
			"digest_on_close" bool true
		]
		"column0_name" string "c_name"
		"column1_name" string "c_address"
		"column2_name" string "c_nationkey"
		"column3_name" string "c_phone"
		"column4_name" string "c_acctbal"
		"column5_name" string "c_mktsegment"
		"column6_name" string "c_comment"
		"column2_config" config [
			"base" class(dt) exception_dtable
			"base_config" config [
				"base" class(dt) smallint_dtable
				"base_config" config [
					"base" class(dt) array_dtable
					"bytes" int 1
				]
				"alt" class(dt) simple_dtable
				"reject_value" blob 00000000
			]
			"digest_on_close" bool true
		]
		"column4_config" config [
			"base" class(dt) array_dtable
			"base_config" config [
				"value_size" int 4
			]
			"digest_on_close" bool true
		]
	]);

/* orders:
 *  o_orderkey,
 *  o_custkey (id),
 *  o_orderstatus (1f),
 *  o_totalprice (float),
 *  o_orderdate (date),
 *  o_orderpriority (15f),
 *  o_clerk (15f),
 *  o_shippriority (int),
 *  o_comment(79v) */
static const char * tpch_orders_config = LITERAL(
	config [
		"columns" int 8
		"base" class(dt) managed_dtable
		"base_config" config [
			"base" class(dt) simple_dtable
			"digest_on_close" bool true
		]
		"column0_name" string "o_custkey"
		"column1_name" string "o_orderstatus"
		"column2_name" string "o_totalprice"
		"column3_name" string "o_orderdate"
		"column4_name" string "o_orderpriority"
		"column5_name" string "o_clerk"
		"column6_name" string "o_shippriority"
		"column7_name" string "o_comment"
		"column0_config" config [
			"base" class(dt) exception_dtable
			"base_config" config [
				"base" class(dt) smallint_dtable
				"base_config" config [
					"base" class(dt) fixed_dtable
					"bytes" int 3
				]
				"alt" class(dt) simple_dtable
				"reject_value" blob 00FFFFFF
			]
			"digest_on_close" bool true
		]
		"column1_config" config [
			"base" class(dt) exception_dtable
			"base_config" config [
				"base" class(dt) fixed_dtable
				"alt" class(dt) simple_dtable
				"reject_value" string "_"
			]
			"digest_on_close" bool true
		]
		"column2_config" config [
			"base" class(dt) fixed_dtable
			"base_config" config [
				"value_size" int 4
			]
			"digest_on_close" bool true
		]
		"column6_config" config [
			"base" class(dt) exception_dtable
			"base_config" config [
				"base" class(dt) smallint_dtable
				"base_config" config [
					"base" class(dt) fixed_dtable
					"bytes" int 1
				]
				"alt" class(dt) simple_dtable
				"reject_value" blob 000000FF
			]
			"digest_on_close" bool true
		]
	]);

/* lineitem:
 *  (no key)
 *  l_orderkey (id),
 *  l_partkey (id),
 *  l_suppkey (id),
 *  l_linenumber (int),
 *  l_quantity (float),
 *  l_extendedprice (float),
 *  l_discount (float),
 *  l_tax (float),
 *  l_returnflag (1f),
 *  l_linestatus (1f),
 *  l_shipdate (date),
 *  l_commitdate (date),
 *  l_receiptdate (date),
 *  l_shipinstruct (25f),
 *  l_shipmode (10f),
 *  l_comment (44v) */
static const char * tpch_lineitem_config = LITERAL(
	config [
		"columns" int 16
		"base" class(dt) managed_dtable
		"base_config" config [
			"base" class(dt) simple_dtable
			"digest_on_close" bool true
		]
		"column0_name" string "l_orderkey"
		"column1_name" string "l_partkey"
		"column2_name" string "l_suppkey"
		"column3_name" string "l_linenumber"
		"column4_name" string "l_quantity"
		"column5_name" string "l_extendedprice"
		"column6_name" string "l_discount"
		"column7_name" string "l_tax"
		"column8_name" string "l_returnflag"
		"column9_name" string "l_linestatus"
		"column10_name" string "l_shipdate"
		"column11_name" string "l_commitdate"
		"column12_name" string "l_receiptdate"
		"column13_name" string "l_shipinstruct"
		"column14_name" string "l_shipmode"
		"column15_name" string "l_comment"
	]);
/* FIXME: customize this */

static ctable * create_and_open(const char * name, const char * config_string)
{
	int r;
	params config;
	ctable * table;
	
	r = params::parse(config_string, &config);
	printf("params::parse = %d\n", r);
	config.print();
	printf("\n");
	
	r = tx_start();
	printf("tx_start = %d\n", r);
	r = ctable_factory::setup("column_ctable", AT_FDCWD, name, config, dtype::UINT32);
	printf("ctable::create = %d\n", r);
	r = tx_end(0);
	printf("tx_end = %d\n", r);
	
	table = ctable_factory::load("column_ctable", AT_FDCWD, name, config);
	printf("ctable_factory::load = %p\n", table);
	
	return table;
}

static void maintain_restart_tx(ctable * table)
{
	int r = table->maintain(true);
	printf("maintain = %d\n", r);
	r = tx_end(0);
	if(r < 0)
		printf("tx_end = %d\n", r);
	else
	{
		r = tx_start();
		if(r < 0)
			printf("tx_start = %d\n", r);
	}
}

/* import the part, customer, orders, and lineitem tables */
int command_tpchgen(int argc, const char * argv[])
{
	int r;
	ctable * table;
	
	/* part */
	table = create_and_open("part", tpch_part_config);
	r = tx_start();
	printf("tx_start = %d\n", r);
	
	tbl_reader<9> part_tbl("tpch/part.tbl");
	while(part_tbl.valid())
	{
		uint32_t key = atoi(part_tbl.get(0));
		uint32_t p_size;
		float p_retailprice;
		const char * char_values[8];
		ctable::ncolval values[8];
		for(size_t i = 0; i < 8; i++)
		{
			values[i].index = i;
			char_values[i] = part_tbl.get(i + 1);
		}
		values[0].value = blob(char_values[0]); /* p_name */
		values[1].value = blob(char_values[1]); /* p_mfgr */
		values[2].value = blob(char_values[2]); /* p_brand */
		values[3].value = blob(char_values[3]); /* p_type */
		p_size = strtol(char_values[4], NULL, 0);
		values[4].value = blob(sizeof(p_size), &p_size);
		values[5].value = blob(char_values[5]); /* p_container */
		p_retailprice = strtod(char_values[6], NULL);
		values[6].value = blob(sizeof(p_retailprice), &p_retailprice);
		values[7].value = blob(char_values[7]); /* p_comment */
		r = table->insert(key, values, 8, true);
		if(r < 0)
			printf("insert = %d\n", r);
		if(!(part_tbl.number() % 100000))
			maintain_restart_tx(table);
		part_tbl.next();
	}
	
	printf("digest_on_close\n");
	delete table;
	r = tx_end(0);
	printf("tx_end = %d\n", r);
	
	/* customer */
	table = create_and_open("customer", tpch_customer_config);
	r = tx_start();
	printf("tx_start = %d\n", r);
	
	tbl_reader<8> customer_tbl("tpch/customer.tbl");
	while(customer_tbl.valid())
	{
		uint32_t key = atoi(customer_tbl.get(0));
		uint32_t c_nationkey;
		float c_acctbal;
		const char * char_values[7];
		ctable::ncolval values[7];
		for(size_t i = 0; i < 7; i++)
		{
			values[i].index = i;
			char_values[i] = customer_tbl.get(i + 1);
		}
		values[0].value = blob(char_values[0]); /* c_name */
		values[1].value = blob(char_values[1]); /* c_address */
		c_nationkey = strtol(char_values[2], NULL, 0);
		values[2].value = blob(sizeof(c_nationkey), &c_nationkey);
		values[3].value = blob(char_values[3]); /* c_phone */
		c_acctbal = strtod(char_values[4], NULL);
		values[4].value = blob(sizeof(c_acctbal), &c_acctbal);
		values[5].value = blob(char_values[5]); /* c_mktsegment */
		values[6].value = blob(char_values[6]); /* c_comment */
		r = table->insert(key, values, 7, true);
		if(r < 0)
			printf("insert = %d\n", r);
		if(!(customer_tbl.number() % 100000))
			maintain_restart_tx(table);
		customer_tbl.next();
	}
	
	printf("digest_on_close\n");
	delete table;
	r = tx_end(0);
	printf("tx_end = %d\n", r);
	
	/* orders */
	table = create_and_open("orders", tpch_orders_config);
	r = tx_start();
	printf("tx_start = %d\n", r);
	
	tbl_reader<9> orders_tbl("tpch/orders.tbl");
	while(orders_tbl.valid())
	{
		uint32_t key = atoi(orders_tbl.get(0));
		uint32_t o_custkey, o_shippriority;
		float o_totalprice;
		const char * char_values[8];
		ctable::ncolval values[8];
		for(size_t i = 0; i < 8; i++)
		{
			values[i].index = i;
			char_values[i] = orders_tbl.get(i + 1);
		}
		o_custkey = strtol(char_values[0], NULL, 0);
		values[0].value = blob(sizeof(o_custkey), &o_custkey);
		values[1].value = blob(char_values[1]); /* o_orderstatus */
		o_totalprice = strtod(char_values[2], NULL);
		values[2].value = blob(sizeof(o_totalprice), &o_totalprice);
		values[3].value = blob(char_values[3]); /* o_orderdate */
		values[4].value = blob(char_values[4]); /* o_orderpriority */
		values[5].value = blob(char_values[5]); /* o_clerk */
		o_shippriority = strtol(char_values[6], NULL, 0);
		values[6].value = blob(sizeof(o_shippriority), &o_shippriority);
		values[7].value = blob(char_values[7]); /* o_comment */
		r = table->insert(key, values, 8, true);
		if(r < 0)
			printf("insert = %d\n", r);
		if(!(orders_tbl.number() % 100000))
			maintain_restart_tx(table);
		orders_tbl.next();
	}
	
	printf("digest_on_close\n");
	delete table;
	r = tx_end(0);
	printf("tx_end = %d\n", r);
	
	/* lineitem */
	table = create_and_open("lineitem", tpch_lineitem_config);
	r = tx_start();
	printf("tx_start = %d\n", r);
	
	tbl_reader<16> lineitem_tbl("tpch/lineitem.tbl");
	while(lineitem_tbl.valid())
	{
		uint32_t key = lineitem_tbl.number();
		uint32_t l_orderkey, l_partkey, l_suppkey, l_linenumber;
		float l_quantity, l_extendedprice, l_discount, l_tax;
		const char * char_values[16];
		ctable::ncolval values[16];
		for(size_t i = 0; i < 16; i++)
		{
			values[i].index = i;
			char_values[i] = lineitem_tbl.get(i);
		}
		l_orderkey = strtol(char_values[0], NULL, 0);
		values[0].value = blob(sizeof(l_orderkey), &l_orderkey);
		l_partkey = strtol(char_values[1], NULL, 0);
		values[1].value = blob(sizeof(l_partkey), &l_partkey);
		l_suppkey = strtol(char_values[2], NULL, 0);
		values[2].value = blob(sizeof(l_suppkey), &l_suppkey);
		l_linenumber = strtol(char_values[3], NULL, 0);
		values[3].value = blob(sizeof(l_linenumber), &l_linenumber);
		l_quantity = strtod(char_values[4], NULL);
		values[4].value = blob(sizeof(l_quantity), &l_quantity);
		l_extendedprice = strtod(char_values[5], NULL);
		values[5].value = blob(sizeof(l_extendedprice), &l_extendedprice);
		l_discount = strtod(char_values[6], NULL);
		values[6].value = blob(sizeof(l_discount), &l_discount);
		l_tax = strtod(char_values[7], NULL);
		values[7].value = blob(sizeof(l_tax), &l_tax);
		values[8].value = blob(char_values[8]); /* l_returnflag */
		values[9].value = blob(char_values[9]); /* l_linestatus */
		values[10].value = blob(char_values[10]); /* l_shipdate */
		values[11].value = blob(char_values[11]); /* l_commitdate */
		values[12].value = blob(char_values[12]); /* l_receiptdate */
		values[13].value = blob(char_values[13]); /* l_shipinstruct */
		values[14].value = blob(char_values[14]); /* l_shipmode */
		values[15].value = blob(char_values[15]); /* l_comment */
		r = table->insert(key, values, 16, true);
		if(r < 0)
			printf("insert = %d\n", r);
		if(!(lineitem_tbl.number() % 100000))
			maintain_restart_tx(table);
		lineitem_tbl.next();
	}
	
	printf("digest_on_close\n");
	delete table;
	r = tx_end(0);
	printf("tx_end = %d\n", r);
	
	return 0;
}

int command_tpchtest(int argc, const char * argv[])
{
	/* #6 select sum(l_extendedprice * l_discount) as revenue
	 * from lineitem
	 * where l_shipdate >= date '[DATE]' and
	 * l_shipdate < date '[DATE]' + interval '1' year and
	 * l_discount between [DISCOUNT] - 0.01 and [DISCOUNT] + 0.01 and
	 * l_quantity < [QUANTITY];
	 * [DATE] is Jan 1 [1993-1997]
	 * [DISCOUNT] in [.02-.09]
	 * [QUANTITY] is 24 or 25 */
	/* #14 select 100 * sum(case when p_type like 'PROMO%' then l_extendedprice * (1 - l_discount) else 0 end)
	 * / sum(l_extendedprice * (1 - l_discount)) as promo_revenue
	 * from lineitem, part
	 * where l_partkey = p_partkey and
	 * l_shipdate >= date '[DATE]' and
	 * l_shipdate < date '[DATE]' + interval '1' month;
	 * [DATE] is [Jan-Dec] 1 [1993-1997]
	 * Types: [STANDARD SMALL MEDIUM LARGE ECONOMY PROMO][ANODIZED BURNISHED PLATED POLISHED BRUSHED][TIN NICKEL BRASS STEEL COPPER] */
	/* #17 select sum(l_extendedprice) / 7.0 as avg_yearly
	 * from lineitem, part
	 * where p_partkey = l_partkey and
	 * p_brand = '[BRAND]' and
	 * p_container = '[CONTAINER]' and
	 * l_quantity < (select 0.2 * avg(l_quantity) from lineitem where l_partkey = p_partkey);
	 * [BRAND] is 'Brand#MN' with M, N in [1-5]
	 * [CONTAINER] [Containers]
	 * Containers: [SM LG MED JUMBO WRAP][CASE BOX BAG JAR PKG PACK CAN DRUM] (page 90) */
	return 0;
}
